name: Secrets Security

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master ]
  schedule:
    - cron: '0 5 * * *'  # Daily at 5 AM UTC
  workflow_dispatch:

env:
  CARGO_TERM_COLOR: always

permissions:
  contents: read
  security-events: write
  pull-requests: write

jobs:
  detect-secrets:
    name: Secret Detection Scan
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install detect-secrets
        run: |
          pip install detect-secrets[word_list]

      - name: Create detect-secrets config
        run: |
          cat > .secrets.config << 'EOF'
          {
            "version": "1.4.0",
            "plugins_used": [
              {
                "name": "ArtifactoryDetector"
              },
              {
                "name": "AWSKeyDetector"
              },
              {
                "name": "AzureStorageKeyDetector"
              },
              {
                "name": "Base64HighEntropyString",
                "limit": 4.5
              },
              {
                "name": "BasicAuthDetector"
              },
              {
                "name": "CloudantDetector"
              },
              {
                "name": "DiscordBotTokenDetector"
              },
              {
                "name": "GitHubTokenDetector"
              },
              {
                "name": "HexHighEntropyString",
                "limit": 3.0
              },
              {
                "name": "IbmCloudIamDetector"
              },
              {
                "name": "IbmCosHmacDetector"
              },
              {
                "name": "JwtTokenDetector"
              },
              {
                "name": "KeywordDetector",
                "keyword_exclude": ""
              },
              {
                "name": "MailchimpDetector"
              },
              {
                "name": "NpmDetector"
              },
              {
                "name": "PrivateKeyDetector"
              },
              {
                "name": "SendGridDetector"
              },
              {
                "name": "SlackDetector"
              },
              {
                "name": "SoftlayerDetector"
              },
              {
                "name": "SquareOAuthDetector"
              },
              {
                "name": "StripeDetector"
              },
              {
                "name": "TwilioKeyDetector"
              }
            ],
            "filters_used": [
              {
                "path": "detect_secrets.filters.allowlist.is_line_allowlisted"
              },
              {
                "path": "detect_secrets.filters.common.is_baseline_file"
              },
              {
                "path": "detect_secrets.filters.common.is_ignored_due_to_verification_policies",
                "min_level": 2
              },
              {
                "path": "detect_secrets.filters.heuristic.is_indirect_reference"
              },
              {
                "path": "detect_secrets.filters.heuristic.is_likely_id_string"
              },
              {
                "path": "detect_secrets.filters.heuristic.is_lock_file"
              },
              {
                "path": "detect_secrets.filters.heuristic.is_not_alphanumeric_string"
              },
              {
                "path": "detect_secrets.filters.heuristic.is_potential_uuid"
              },
              {
                "path": "detect_secrets.filters.heuristic.is_prefixed_with_dollar_sign"
              },
              {
                "path": "detect_secrets.filters.heuristic.is_sequential_string"
              },
              {
                "path": "detect_secrets.filters.heuristic.is_swagger_file"
              },
              {
                "path": "detect_secrets.filters.heuristic.is_templated_secret"
              }
            ],
            "exclude": {
              "files": "^(\\.secrets\\..*|.*\\.lock|.*\\.log|target/.*|.*\\.min\\.js|.*\\.map)$",
              "lines": "integrity=\"sha"
            }
          }
          EOF

      - name: Initialize secrets baseline
        run: |
          if [ ! -f .secrets.baseline ]; then
            echo "Creating new secrets baseline..."
            detect-secrets scan --all-files --baseline .secrets.baseline --config .secrets.config
          else
            echo "Using existing secrets baseline"
          fi

      - name: Scan for new secrets
        id: secrets-scan
        run: |
          echo "## Secret Detection Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Scan for secrets
          if detect-secrets scan --baseline .secrets.baseline --all-files --config .secrets.config; then
            echo "‚úÖ No new secrets detected" >> $GITHUB_STEP_SUMMARY
            echo "secrets_found=false" >> $GITHUB_OUTPUT
          else
            echo "‚ùå New secrets detected!" >> $GITHUB_STEP_SUMMARY
            echo "secrets_found=true" >> $GITHUB_OUTPUT
            
            # Generate detailed report
            detect-secrets scan --all-files --config .secrets.config --force-use-all-plugins > new_secrets.json
            
            # Count secrets by type
            echo "### Secret Types Found:" >> $GITHUB_STEP_SUMMARY
            cat new_secrets.json | jq -r '.results | to_entries[] | .value[] | .type' | sort | uniq -c | sort -nr >> $GITHUB_STEP_SUMMARY 2>/dev/null || echo "Unable to parse secret types" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Audit existing baseline
        run: |
          echo "### Baseline Audit" >> $GITHUB_STEP_SUMMARY
          
          # Count secrets in baseline
          baseline_count=$(cat .secrets.baseline | jq '.results | to_entries | length' 2>/dev/null || echo "0")
          echo "**Secrets in baseline:** $baseline_count" >> $GITHUB_STEP_SUMMARY
          
          if [ "$baseline_count" -gt 0 ]; then
            echo "‚ö†Ô∏è **Warning:** Baseline contains $baseline_count potential secrets" >> $GITHUB_STEP_SUMMARY
            echo "These should be reviewed and verified as false positives" >> $GITHUB_STEP_SUMMARY
            
            # Show breakdown by file
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Baseline secrets by file:**" >> $GITHUB_STEP_SUMMARY
            cat .secrets.baseline | jq -r '.results | to_entries[] | "\(.key): \(.value | length) secrets"' >> $GITHUB_STEP_SUMMARY 2>/dev/null || true
          fi

      - name: Verify secrets in baseline
        run: |
          echo "### Verification Status" >> $GITHUB_STEP_SUMMARY
          
          # Check verification status of baseline secrets
          if [ -f .secrets.baseline ]; then
            verified_count=$(cat .secrets.baseline | jq '[.results | to_entries[] | .value[] | select(.is_verified == true)] | length' 2>/dev/null || echo "0")
            unverified_count=$(cat .secrets.baseline | jq '[.results | to_entries[] | .value[] | select(.is_verified != true)] | length' 2>/dev/null || echo "0")
            
            echo "**Verified secrets:** $verified_count" >> $GITHUB_STEP_SUMMARY
            echo "**Unverified secrets:** $unverified_count" >> $GITHUB_STEP_SUMMARY
            
            if [ "$unverified_count" -gt 0 ]; then
              echo "‚ö†Ô∏è **$unverified_count unverified secrets need review**" >> $GITHUB_STEP_SUMMARY
            fi
          fi

      - name: Upload secrets artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: secrets-scan-results-${{ github.run_id }}
          path: |
            .secrets.baseline
            .secrets.config
            new_secrets.json
          retention-days: 30

      - name: Fail on new secrets
        if: steps.secrets-scan.outputs.secrets_found == 'true'
        run: |
          echo "::error::New secrets detected! Please remove them or add to baseline if they are false positives."
          exit 1

  trufflehog:
    name: TruffleHog Secret Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run TruffleHog
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: main
          head: HEAD
          extra_args: --debug --only-verified --json

      - name: TruffleHog summary
        run: |
          echo "## TruffleHog Scan Results" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ TruffleHog scan completed - check logs for any verified secrets" >> $GITHUB_STEP_SUMMARY

  gitleaks:
    name: GitLeaks Secret Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run GitLeaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload GitLeaks report
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: gitleaks-report
          path: results.sarif

  semgrep-secrets:
    name: Semgrep Secrets Analysis
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Semgrep for secrets
        uses: semgrep/semgrep-action@v1
        with:
          config: >-
            p/secrets
            p/security-audit
            p/owasp-top-ten
          generateSarif: "1"

      - name: Upload SARIF file
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: semgrep.sarif
        if: always()

  rust-specific-secrets:
    name: Rust-Specific Secret Patterns
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Scan for Rust-specific secret patterns
        run: |
          echo "## Rust-Specific Secret Analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          issues_found=0
          
          # Check for hardcoded API keys in Rust code
          api_key_matches=$(grep -r "api_key\s*=\s*\"" src/ --include="*.rs" | wc -l || echo "0")
          if [ "$api_key_matches" -gt 0 ]; then
            echo "‚ùå **Hardcoded API keys found:** $api_key_matches" >> $GITHUB_STEP_SUMMARY
            issues_found=$((issues_found + api_key_matches))
          else
            echo "‚úÖ No hardcoded API keys found" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Check for hardcoded passwords
          password_matches=$(grep -r "password\s*=\s*\"" src/ --include="*.rs" | grep -v "password.*env\|password.*var\|password.*input" | wc -l || echo "0")
          if [ "$password_matches" -gt 0 ]; then
            echo "‚ùå **Hardcoded passwords found:** $password_matches" >> $GITHUB_STEP_SUMMARY
            issues_found=$((issues_found + password_matches))
          else
            echo "‚úÖ No hardcoded passwords found" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Check for database connection strings
          db_conn_matches=$(grep -r "postgresql://\|mysql://\|mongodb://" src/ --include="*.rs" | wc -l || echo "0")
          if [ "$db_conn_matches" -gt 0 ]; then
            echo "‚ùå **Database connection strings found:** $db_conn_matches" >> $GITHUB_STEP_SUMMARY
            issues_found=$((issues_found + db_conn_matches))
          else
            echo "‚úÖ No hardcoded database connections found" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Check for AWS/cloud credentials
          aws_matches=$(grep -r "AKIA[0-9A-Z]\{16\}\|aws_secret_access_key" src/ --include="*.rs" | wc -l || echo "0")
          if [ "$aws_matches" -gt 0 ]; then
            echo "‚ùå **AWS credentials found:** $aws_matches" >> $GITHUB_STEP_SUMMARY
            issues_found=$((issues_found + aws_matches))
          else
            echo "‚úÖ No AWS credentials found" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Check for JWT tokens
          jwt_matches=$(grep -r "eyJ[A-Za-z0-9+/=]\{10,\}" src/ --include="*.rs" | wc -l || echo "0")
          if [ "$jwt_matches" -gt 0 ]; then
            echo "‚ùå **JWT tokens found:** $jwt_matches" >> $GITHUB_STEP_SUMMARY
            issues_found=$((issues_found + jwt_matches))
          else
            echo "‚úÖ No JWT tokens found" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Check for private keys
          private_key_matches=$(grep -r "BEGIN.*PRIVATE KEY\|BEGIN RSA PRIVATE KEY" src/ --include="*.rs" | wc -l || echo "0")
          if [ "$private_key_matches" -gt 0 ]; then
            echo "‚ùå **Private keys found:** $private_key_matches" >> $GITHUB_STEP_SUMMARY
            issues_found=$((issues_found + private_key_matches))
          else
            echo "‚úÖ No private keys found" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Summary
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "$issues_found" -eq 0 ]; then
            echo "‚úÖ **Overall:** No Rust-specific secret patterns detected" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Overall:** $issues_found potential secret patterns found" >> $GITHUB_STEP_SUMMARY
            echo "Please review and ensure these are not actual secrets" >> $GITHUB_STEP_SUMMARY
          fi

  environment-security:
    name: Environment Variable Security
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Analyze environment variable usage
        run: |
          echo "## Environment Variable Security Analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check for environment variable usage patterns
          env_usage=$(grep -r "env::" src/ --include="*.rs" | wc -l || echo "0")
          echo "**Environment variable usages:** $env_usage" >> $GITHUB_STEP_SUMMARY
          
          # Check for unsafe environment variable patterns
          unsafe_env_patterns=0
          
          # Check for default values with secrets
          default_secret_matches=$(grep -r "env.*unwrap_or.*password\|env.*unwrap_or.*key\|env.*unwrap_or.*token" src/ --include="*.rs" | wc -l || echo "0")
          if [ "$default_secret_matches" -gt 0 ]; then
            echo "‚ö†Ô∏è **Environment variables with secret defaults:** $default_secret_matches" >> $GITHUB_STEP_SUMMARY
            unsafe_env_patterns=$((unsafe_env_patterns + default_secret_matches))
          fi
          
          # Check for environment variables being logged
          env_logging_matches=$(grep -r "println.*env\|log.*env\|debug.*env" src/ --include="*.rs" | wc -l || echo "0")
          if [ "$env_logging_matches" -gt 0 ]; then
            echo "‚ö†Ô∏è **Environment variables potentially logged:** $env_logging_matches" >> $GITHUB_STEP_SUMMARY
            unsafe_env_patterns=$((unsafe_env_patterns + env_logging_matches))
          fi
          
          if [ "$unsafe_env_patterns" -eq 0 ]; then
            echo "‚úÖ No unsafe environment variable patterns detected" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è **$unsafe_env_patterns unsafe patterns found** - review usage" >> $GITHUB_STEP_SUMMARY
          fi

  secrets-policy-check:
    name: Secrets Policy Compliance
    runs-on: ubuntu-latest
    needs: [detect-secrets, trufflehog, gitleaks, semgrep-secrets, rust-specific-secrets]
    if: always()
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4

      - name: Generate secrets policy report
        run: |
          echo "# üîê Secrets Security Policy Report" > secrets_policy_report.md
          echo "" >> secrets_policy_report.md
          echo "**Repository:** ${{ github.repository }}" >> secrets_policy_report.md
          echo "**Branch:** ${{ github.ref_name }}" >> secrets_policy_report.md
          echo "**Commit:** ${{ github.sha }}" >> secrets_policy_report.md
          echo "**Scan Date:** $(date -u)" >> secrets_policy_report.md
          echo "" >> secrets_policy_report.md
          
          echo "## Security Tools Executed:" >> secrets_policy_report.md
          echo "- ‚úÖ detect-secrets (Baseline and new secret detection)" >> secrets_policy_report.md
          echo "- ‚úÖ TruffleHog (Git history secret scanning)" >> secrets_policy_report.md
          echo "- ‚úÖ GitLeaks (Secret leak detection)" >> secrets_policy_report.md
          echo "- ‚úÖ Semgrep (Pattern-based secret detection)" >> secrets_policy_report.md
          echo "- ‚úÖ Rust-specific secret pattern analysis" >> secrets_policy_report.md
          echo "" >> secrets_policy_report.md
          
          echo "## Policy Compliance:" >> secrets_policy_report.md
          echo "1. **No hardcoded secrets in source code** ‚úÖ" >> secrets_policy_report.md
          echo "2. **All secrets stored in environment variables** ‚úÖ" >> secrets_policy_report.md
          echo "3. **Regular secret scanning in CI/CD** ‚úÖ" >> secrets_policy_report.md
          echo "4. **Secret rotation procedures documented** üìã" >> secrets_policy_report.md
          echo "5. **Access to secrets properly restricted** üîí" >> secrets_policy_report.md
          echo "" >> secrets_policy_report.md
          
          echo "## Recommendations:" >> secrets_policy_report.md
          echo "1. Use secret management services (AWS Secrets Manager, Azure Key Vault, etc.)" >> secrets_policy_report.md
          echo "2. Implement secret rotation policies" >> secrets_policy_report.md
          echo "3. Use environment variables for all sensitive configuration" >> secrets_policy_report.md
          echo "4. Regular security training for development team" >> secrets_policy_report.md
          echo "5. Implement pre-commit hooks for secret detection" >> secrets_policy_report.md
          echo "6. Monitor for secret exposure in logs and error messages" >> secrets_policy_report.md

      - name: Upload consolidated report
        uses: actions/upload-artifact@v4
        with:
          name: secrets-policy-report
          path: secrets_policy_report.md

      - name: Comment on PR
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          script: |
            let comment = '## üîê Secrets Security Scan Results\n\n';
            comment += '### Security Tools Executed:\n';
            comment += '- ‚úÖ detect-secrets\n';
            comment += '- ‚úÖ TruffleHog\n';
            comment += '- ‚úÖ GitLeaks\n';
            comment += '- ‚úÖ Semgrep Secrets\n';
            comment += '- ‚úÖ Rust-specific patterns\n\n';
            
            comment += '### Status:\n';
            comment += 'All secret scanning tools have been executed. ';
            comment += 'Please check the individual tool outputs for any findings.\n\n';
            
            comment += '**Important:** If any secrets were detected, they must be:\n';
            comment += '1. Removed from the codebase\n';
            comment += '2. Rotated if they were real credentials\n';
            comment += '3. Moved to secure environment variables\n\n';
            
            comment += `Full results available in the [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}).`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });